# This YAML file provides information about each criterion.
# The top level key is the major (top-level) group key,
# within that is the minor (secondary) group key,
# and within each minor group is a set of criteria identifiers.
# With each criterion identifiers the following keys may be inside:
#   category: MUST|SHOULD|SUGGESTED # required
#   future: true|false # optional, default false
#   na_allowed: true|false # optional, default false
#   na_justification_required: true|false # optional, default false
#   met_justification_required: true|false # optional, default false
#   met_url_required: true|false # optional, default false
#   description: ...HTML description... # required
#   details: ...HTML description... # optional
#   met_placeholder: ...special met_placeholder text... # optional
#   unmet_placeholder: ...special unmet_placeholder text... # optional
#   na_placeholder: ...special na_placeholder text... # optional
#   met_suppress: true|false # optional, default false. Suppress justification?
#   unmet_suppress: true|false # optional, default false. Suppress just.
#   rationale: ...text describing the rationale for this criterion.
#   autofill: ...text describing *ideas* for how to autofill, in markdown
#
# Please note that autofill text is *not* a guarantee of how it will
# be implemented (or even if it will be automated); it is simply a way
# to record ideas that might be implemented.  Also, autofill is often
# used to *guess* correct values, to help speed filling in the form;
# we only force values if we are confident in their answer or are willing
# to require that the information be provided in a specific way.
# We've focused on GitHub, but where reasonable we'd like to create
# portability layers and support other forges like SourceForge,
# Savannah, Bitbucket, and GitLab; we'd also like to be able to support
# standalone sites (e.g., detect use of Bugzilla and work with that).
#
# We use an *ordered* map (omap), because the order below is used to determine
# the order of presentation.  In Ruby this doesn't really matter because
# (current) Ruby hashes are ordered anyway. We use !!omap so that
# any other tool reading this format will know to preserve the order.
--- !!omap
- '0':
  - Basics: !!omap
    - Basic Project Website Content: !!omap
      - description_good:
          category: MUST
          autofill: >
            We could try examining the project website or README for an
            early sentence of the form (This software|project name).
            It's unclear how effective this would be; we could survey a number
            of existing projects to see if there are common patterns.
      - interact:
          category: MUST
          autofill: >
            Look on the project website for words like "download|obtain",
            "contribute|bug report|feedback|enhancement", and
            "contribute|pull request|merge request".
      - contribution:
          category: MUST
          met_url_required: true
          autofill: >
            Look on the project website for words like
            "contribute|bug report|feedback|enhancement" and
            "contribute|pull request|merge request".
          rationale: >
            Contributors need to understand not only how to contribute,
            but also the overall contribution process, so that they'll
            understand how their work could be incorporated and what
            the expectations are after the initial submission.
            This means that wherever the project describes how to contribute,
            the project must include (directly or by reference) information
            on the contribution process.  Note that criterion "interact"
            (listed earlier) requires that the contribution information
            be on the project website.
      - contribution_requirements:
          category: SHOULD
          met_url_required: true
          autofill: >
            Look for a CONTRIBUTING{,.md,.txt,.html} file.
    - OSS License: !!omap
      - floss_license:
          category: MUST
          rationale: >
            These criteria are designed for FLOSS projects,
            so we need to ensure that they're only used where they apply.
            Some projects may be mistakenly considered FLOSS even though they
            are not (e.g., they might not have any license, in which case the
            defaults of the country's legal system apply, or they might use a
            non-FLOSS license).
            We've added "produced by the project" as a clarification -
            many projects use non-FLOSS software/services in the process of
            creating software, or depend on them to run,
            and that is allowed.
          autofill: >
            We currently use GitHub's API to request license information.
            This API examines the LICENSE file using the gem licensee.
            This only works on GitHub, and only in simple cases
            (when there's a single license).
            We could in addition look for the file LICENSE.spdx for the
            entry 'PackageLicenseDeclared' - these aren't included often,
            but it would let people declare *exactly* what license is in use.
            We could add running Ben Balter's gem
            [licensee](https://github.com/benbalter/licensee), this is the same
            library used by GitHub but we can then apply it outside of GitHub.
            [Licensee issue #85](https://github.com/benbalter/licensee/issues/85)
            proposes adding LICENSE.spdx support to licensee.
            See [&#8220;Open Source Licensing by the Numbers&#8221; by Ben Balter](https://speakerdeck.com/benbalter/open-source-licensing-by-the-numbers).
            We could also do more specialized analysis (e.g., looking for
            license information in various packaging formats) - this would
            probably be best done by improving some existing library
            like licensee.
      - floss_license_osi:
          category: SUGGESTED
          met_suppress: true
          rationale: >
            Unusual licenses can cause long-term problems
            for FLOSS projects and are more difficult for tools to handle.
            That said, there are FLOSS licenses that are not OSI-approved,
            e.g., the CC0 license is used by many projects but is not
            OSI-approved at the time of this writing.
            We expect that more advanced badges would set a higher bar (e.g.,
            that it <em>must</em> be released under an OSI-approved license).
          autofill: >
            Currently we compare the license to see if it's on a simple list
            from OSI.  We could add support for automatically getting the list
            from elsewhere (e.g., OSI or SPDX), and support more complex
            license structures (OR, AND, and WITH).
      - license_location:
          category: MUST
          met_url_required: true
          rationale: >
            The goal is to make the license very clear and connected with
            the project results it applies to.  It is a good idea to also
            make the license clear on the project website, but there isn't
            a widely-accepted way to do that today.
          autofill: >
            Look for files with the name LICENSE, COPYING, or COPYING-(name)
            optionally extensions .txt or .md.  Name could include
            GPL, LGPL, and MIT.
    - Documentation: !!omap
      - documentation_basics:
          category: MUST
          na_allowed: true
          na_justification_required: true
          rationale: >
            Potential users need documentation so that they can learn how to
            use the software.
            This documentation could be provided
            via the project website or repository, or even
            via hyperlink to some external information, so we do not specify
            exactly where this information is.
          autofill: >
            Look for the project web page,
            or a direct links from it on the same site,
            that includes words like "install(ation)?", "use|using",
            and "security|secure".
            If examining the project repo discovers a nontrivial amount of code,
            then this should not be N/A.
      - documentation_interface:
          category: MUST
          na_allowed: true
          na_justification_required: true
          autofill: >
            Look for a "docs" or "doc" directory, or the main site, with
            .txt, .html, .md, .tex extension and uses the word "interface".
            If examining the project repo discovers a nontrivial amount of code,
            then this should not be N/A.
    - Other: !!omap
      - sites_https:
          category: MUST
          autofill: >
            Look at project, repo, and download URLs. https is okay, http is not.
            Typically anything supporting HTTPS also supports TLS, so
            it's probably not worth trying to detect that specifically.
      - discussion:
          category: MUST
          autofill: >
            Currently if it's on GitHub we assume they will use its mechanisms.
            We could do the same for other forges like
            SourceForge, GitLab, and Savannah.
            We could also look for links from the project website that suggest
            the use of Bugzilla, Mantis, or Trac.
      - english:
          category: SHOULD
          autofill: >
            Look at project and/or repo page.  If it's in English,
            then clearly the project can accept English.
            We can use more general tools to detect the natural language,
            or simple mechanisms like using dictionaries/spellcheckers to
            see if it's mostly English.
  - 'Change Control': !!omap
    - Public version-controlled source repository: !!omap
      - repo_public:
          category: MUST
          autofill: >
            We currently assume that being on GitHub is enough.
            Again, consider supporting other forges.
      - repo_track:
          category: MUST
          autofill: >
            If it uses git, subversion (svn), mercurial (hg), or even CVS
            this would normally be met.
      - repo_interim:
          category: MUST
          autofill: >
            Consider checking if there are many versions.  If versions are
            only posted once every 3+ months, there's probably a problem.
      - repo_distributed:
          category: SUGGESTED
          autofill: >
            Look for git, subversion (svn), and mercurial (hg).
    - Unique version numbering: !!omap
      - version_unique:
          category: MUST
          autofill: >
            Look for downloads with version numbers in the filename, or
            version tags in a git repo.
      - version_semver:
          category: SUGGESTED
          rationale: >
            SemVer is widely used to communicate what an update
            is (e.g., if it involves incompatible API changes),
            whether something is newer or older.  The scheme is simple,
            supports multiple simultaneous branches, and because it uses at
            least three numbers it can be distinguished from floating point.
            However, many find SemVer less useful for identifying software
            versions if only one version of the component is run (e.g.,
            it is the code for a single website or internet service that
            is constantly updated via continuous delivery).
            For more discussion of the pros and cons of SemVer, see
            <a href="https://news.ycombinator.com/item?id=13378637">Hacker News' Is Semantic Versioning an Anti-Pattern?</a> and
            <a href="https://surfingthe.cloud/semantic-versioning-anti-pattern/">The Semantic Versioning Anti-Pattern</a>.
          met_suppress: true
          autofill: >
            Look for git tags (at least on GitHub) that have version format, e.g.,
            v?[0-9]+\.[0-9]+\.[0-9]+.*   The prefixed 'v' is
            sometimes used in tags.
      - version_tags:
          category: SUGGESTED
          autofill: >
            Again, look for git tags (at least on GitHub) that have
            version format, e.g., v?[0-9]+\.[0-9]+\.[0-9]+.*   The
            prefixed 'v' is sometimes used in tags.
    - Release notes: !!omap
      - release_notes:
          category: MUST
          met_url_required: true
          na_allowed: true
          na_justification_required: true
          rationale: >
            Release notes are important because they help users decide whether
            or not they will want to update, and what the impact would be (e.g.,
            if the new release fixes vulnerabilities).  We realize this may not
            apply to projects whose main results are continuously updated and
            are deployed to primarily one place and so allow "N/A" from
            such projects.
          autofill: >
            Look for version-controlled files named NEWS, CHANGELOG, or ChangeLog
            (optionally with an extension .txt, .md, or .html).
            Also check to see if it uses a GitHub Releases workflow.
      - release_notes_vulns:
          category: MUST
          na_allowed: true
          na_justification_required: true
          autofill: >
            Examine the release notes (per above) to see if they include
            CVE identifiers.  Also,
            use a vulnerability database such as the
            National Vulnerability Database (NVD) to try to identify
            publicly known vulnerabilities in this software, and see if all of
            them are mentioned in the release notes.
  - Reporting: !!omap
    - Bug-reporting process: !!omap
      - report_process:
          category: MUST
          met_url_required: true
          autofill: >
            On GitHub we presume that at least issue trackers can be used.
            Search CONTRIBUTING (if it exists) for a phrase like "bug reports".
      - report_tracker:
          category: SHOULD
          autofill: >
            On GitHub we presume that at least issue trackers can be used.
            Search CONTRIBUTING (if it exists) for a phrase like "issue tracker".
      - report_responses:
          category: MUST
          autofill: >
            Examine issue tracker, and see what is marked as a "bug".
            Exclude the top contributor(s) as reported by the repo changes.
            Then examine the responses for the rest.
            Measuring "top contributors" is tricky; one potential rule is
            those who contribute more than 10% of the system, or, when you
            sort people by their contributions, the ones who cumulatively wrote
            2/3s of the system.  However,
            these measures may be difficult to obtain
            in a short time - perhaps just exclude anyone listed in AUTHORS or
            CREDITS, or someone listed in the last X commits?
      - enhancement_responses:
          category: SHOULD
          autofill: >
            Examine issue tracker, and see what is marked as an "enhancement".
            Exclude the top contributor(s) as reported by the repo changes.
            Then examine the responses for the rest.
      - report_archive:
          category: MUST
          met_url_required: true
          autofill: >
            If on GitHub, Savannah, SourceForge, GitLab, this is probably fine.
    - Vulnerability report process: !!omap
      - vulnerability_report_process:
          category: MUST
          met_url_required: true
          autofill: >
            Look for phrase like "vulnerability reporting" or
            "how to report vulnerabilities" in various documents
            like README, CONTRIBUTING, or a doc/* file.
      - vulnerability_report_private:
          category: MUST
          na_allowed: true
          met_url_required: true
          autofill: >
            Look for a phrase like "private vulnerability reporting" or
            "how to report private vulnerabilities" in various documents
            like README, CONTRIBUTING, or a doc/* file, and *also*
            look for an OpenPGP key to use for encrypting the information.
            Sadly, while Bugzilla easily supports this,
            GitHub doesn't currently support this in its issue tracker, see
            https://github.com/isaacs/github/issues/37
      - vulnerability_report_response:
          category: MUST
          na_allowed: true
          autofill: >
            If GitHub is used, and the issue tracker has something marked
            "security" or "vulnerability", measure the appropriate times.
            GitHub doesn't support private reports, though, so a lot of people
            won't use this.
            If Bugzilla is used, grab the information publicly available and
            track this.
  - Quality: !!omap
    - Working build system: !!omap
      - build:
          category: MUST
          na_allowed: true
          rationale: >
            If a project needs to be built but there is no
            working build system, then potential co-developers will not be
            able to easily contribute and many security analysis tools will be
            ineffective.
            This is related to
            <a href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/">Joel Test</a>
            point 2, "Can you make a build in one step?"
          autofill: >
            See build_common_tools.
      - build_common_tools:
          category: SUGGESTED
          na_allowed: true
          autofill: >
            Look for files that suggest the use of a common build systems, e.g.:
            the autotools (configure.ac, makefile.am),
            traditional make (Makefile, makefile),
            cmake, rake, ant, maven, etc.
            See http://www.dwheeler.com/essays/releasing-floss-software.html
      - build_floss_tools:
          category: SHOULD
          na_allowed: true
          autofill: >
            If it's packaged in a Linux distribution repo that is FLOSS-only,
            then this is met.  That includes official Debian distribution
            (but not contrib or non-free) or Fedora's official distribution.
            If it's only source code file extensions that don't normally require
            building (.py, .rb, etc.), then it is likely NA.
            If the build_common_tools answers are themselves FLOSS, then this
            is more likely to *also* be true.  The only *real* way to check this
            is to install and build on a system that only has FLOSS, and we
            won't have the time to do that ourselves.
    - Automated test suite: !!omap
      - test:
          category: MUST
          rationale: >
            Automated test suites immediately help detect a
            variety of problems.  A large test suite can find more problems, but
            even a small test suite can detect problems and provide a framework
            to build on.
          autofill: >
            See test_invocation, and use its value here also.
      - test_invocation:
          category: SHOULD
          autofill: >
            Look in the build scripts for a non-empty test command.
            E.g., look for a Makefile (including Makefile.am) with a non-empty
            "check" or "test" entry.  Similarly look for an entry for
            maven (mvn test) or rake (rake test).
      - test_most:
          category: SUGGESTED
          autofill: >
            We could run a test suite with coverage enabled, but that would
            take far too long for our time budget.
            However, we *could* look for a Coveralls or Codecov badge
            (a link to a badge under <https://coveralls.io>) and pull in
            *that* data (since that would be the final result).
            Coveralls or Code prefer 90% or more statement coverage.
      - test_continuous_integration:
          category: SUGGESTED
          autofill: >
            Look for a .travis.yml or circle.yml file.
            We also see if it has a badge from CircleCI or Travis.
            Extra points: We could ask Travis or CircleCI if it's enabled.
            We could look for evidence of pulls each of which are "relatively"
            small (instead of rare massive changes being the norm), though
            that by itself would give less confidence.
            Also, make this depend on the "test" or "test_invocation" criterion.
    - New functionality testing: !!omap
      - test_policy:
          category: MUST
          autofill: >
            Look for text patterns hinting at this in README, CONTRIBUTING,
            or the doc/* directory.
            Also, make this depend on the "test" or "test_invocation" criterion.
      - tests_are_added:
          category: MUST
          autofill: >
            Look for evidence that new tests are created.
            E.G., do at least some contributions include new tests
            (e.g., changes to contents in a directory whose full pathname
            contains the phrase "test").
      - tests_documented_added:
          category: SUGGESTED
          autofill: >
            Look in CONTRIBUTING and README.  See also test_policy.
    - Warning flags: !!omap
      - warnings:
          category: MUST
          na_allowed: true
          autofill: >
            See the "details" - search the build script and source code for these.
      - warnings_fixed:
          category: MUST
          na_allowed: true
          autofill: >
            The only good way to do this is to actually do a build.
            If it uses CircleCI we could look at that.
      - warnings_strict:
          category: SUGGESTED
          na_allowed: true
          autofill: >
            If we find "-Wall -Wextra" in the build that's pretty strict.
  - Security: !!omap
    - Secure development knowledge: !!omap
      - know_secure_design:
          category: MUST
          autofill: >
            We could try to search the documentation for evidence of phrases
            that suggest security knowledge, such as the phrases listed above.
      - know_common_errors:
          category: MUST
          autofill: >
            We could try to search the documentation for evidence of phrases
            that suggest security knowledge, such as the phrases for common
            types of vulnerabilities such as CWE/SANS top 25 or OWASP top 10.
            Simply mentioning those could also be an indicator.
    - Use basic good cryptographic practices: !!omap
      - crypto_published:
          category: MUST
          na_allowed: true
          # autofill: TODO
      - crypto_call:
          category: SHOULD
          na_allowed: true
          # autofill: TODO
      - crypto_floss:
          category: MUST
          na_allowed: true
          rationale: >
            Software must interoperate with other software. If the
            functionality cannot be implemented with FLOSS, e.g., because
            of patents, then this can set a trap for others who depend on
            the software.
          # autofill: TODO
      - crypto_keylength:
          category: MUST
          na_allowed: true
          # autofill: TODO
      - crypto_working:
          category: MUST
          na_allowed: true
          rationale: >
            If a cryptographic algorithm or mode is completely broken,
            then it cannot provide a useful cryptographic service.
            This is different from having a weakness;
            many cryptographic algorithms have some weaknesses, yet for
            backwards-compatibility it may sometimes be appropriate to use
            the algorithm anyway.
            "EAX" appears to be a name, not an abbrevation.
            The paper describing EAX,
            <a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/eax/eax-spec.pdf">"A
            Conventional Authenticated-Encryption Mode" by
            M. Bellare, P.  Rogaway D.  Wagner (April 13, 2003)</a>,
            does not give an expansion.
          # autofill: TODO
      - crypto_weaknesses:
          category: SHOULD
          na_allowed: true
          rationale: >
            SHA-1 has been known to be weak for many years;
            <a href="https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html">In February 2017 Google demonstrated a SHA-1 collision</a>.
            There are a number of alternatives to SHA-1 that are not
            patent-encumbered, such as the
            SHA-2 suite (including SHA-256 and SHA-512) and SHA-3.
            There is some disagreement on how important it is to avoid
            CBC mode in SSH.  The
            <a href="http://www.openssh.com/txt/cbc.adv">OpenSSH cbc.adv</a>
            page argues that the attack on SSH CBC is not a practical attack.
            However, others clearly think it's more important; CERT notes it,
            as does
            <a href="https://developer.ibm.com/answers/questions/187318/faq-how-do-i-disable-cipher-block-chaining-cbc-mod.html">FAQ: Disable CBC in SSH</a>.
            It is also easy to use a different mode than CBC; generally
            when there are safer widely-available options, you should use
            the safe ones instead.
            This is a SHOULD, not a MUST; sometimes these weaker
            mechanisms need to be used for backwards compatibility.
          # autofill: TODO
      - crypto_pfs:
          category: SHOULD
          na_allowed: true
          # autofill: TODO
      - crypto_password_storage:
          category: MUST
          na_allowed: true
          rationale: >
            This is a bare minimum today when storing passwords.
            Sometimes software needs to have a credential, such as a password,
            to authenticate it to other systems; those are intentionally
            out of scope for this criterion, because in many cases it's not
            possible to store them as iterated hashes using per-user salt.
          # autofill: TODO
      - crypto_random:
          category: MUST
          na_allowed: true
          # autofill: TODO
    - Secured delivery against man-in-the-middle (MITM) attacks: !!omap
      - delivery_mitm:
          category: MUST
          autofill: >
            Look for a download site using https.
      - delivery_unsigned:
          category: MUST
          autofill: >
            Again, look for a download site using https.
    - Publicly known Vulnerabilities fixed: !!omap
      - vulnerabilities_fixed_60_days:
          category: MUST
          rationale: >
            We intentionally chose to start measurement from the
            time of public knowledge,
            and not from the time reported to the project, because this is much
            easier to measure and
            verify by those outside the project.
          autofill: >
            Look at vulnerability databases (such as NVD),
            pull out unpatched ones, and look at days since report.
      - vulnerabilities_critical_fixed:
          category: SHOULD
          autofill: >
             Look at vulnerability databases for say the last 2 years, and
             find the worst-case time for response to any
             critical vulnerabilities.
             More than 60 days is not a good sign.
    - Other security issues: !!omap
      - no_leaked_credentials:
          category: MUST
          autofill: >
            Search repo for filenames that suggest credential leaking, e.g.,
            id_dsa (SSH private key).  Could also look at file contents for
            things like Amazon keys or Heroku keys.
            Could look at .env file, though "SECRETS" there might not really
            be secrets.
  - Analysis: !!omap
    - Static code analysis: !!omap
      - static_analysis:
          category: MUST
          na_allowed: true
          met_justification_required: true
          na_justification_required: true
          autofill: >
            Look in build scripts for execution of common tools, and in
            documentation for names of tools and the URL of a Coverity scan entry.
      - static_analysis_common_vulnerabilities:
          category: SUGGESTED
          na_allowed: true
          autofill: >
            We might start by looking primarily for tools that also meet this.
            E.g., brakeman for Ruby on Rails.
      - static_analysis_fixed:
          category: MUST
          na_allowed: true
          # autofill: TODO
      - static_analysis_often:
          category: SUGGESTED
          na_allowed: true
          autofill: >
            Look for commit hooks or continuous integration tools like CircleCI
            that would meet this.
    - Dynamic code analysis: !!omap
      - dynamic_analysis:
          category: SUGGESTED
          rationale: >
            Static source code analysis and dynamic analysis tend
            to find different kinds of defects (including defects that lead to
            vulnerabilities), so combining them is more likely to be effective.
          autofill: >
            Look in documentation for references to such tools.
      - dynamic_analysis_unsafe:
          category: SUGGESTED
          na_allowed: true
          autofill: >
            Look in build/test script for reference to invocation of
            valgrind or ASAN.
      - dynamic_analysis_enable_assertions:
          category: SUGGESTED
          autofill: >
            Perhaps look in source code for many asserts.
      - dynamic_analysis_fixed:
          category: MUST
          na_allowed: true
          # autofill: TODO
  - Future: !!omap
    - future: !!omap
      - installation_common: # Put after 'english'
          category: SHOULD
          future: true
          autofill: >
            Look for a standard install format, or a build instruction for one.
      - build_reproducible: # After build_floss_tools
          category: SUGGESTED
          future: true
          na_allowed: true
          rationale: >
            If a project needs to be built but there is no working
            build system, then potential co-developers will not be able to easily
            contribute and many security analysis tools will be ineffective.
            Reproduceable builds counter malicious attacks that generate malicious
            executables, by making it easy to recreate the executable to determine
            if the result is correct.
            By itself, reproducible builds do not counter malicious compilers,
            but they can be extended to counter malicious compilers using
            processes such as diverse double-compiling (DDC).
          autofill: >
            If the project seems to only have scripting language code,
            prefill it as N/A.
            Otherwise, check if the reproducible build project lists the project
            as being reproducible.
            The only *real* way to check is to actually perform the build
            multiple times, but we don't have time for that.
      - crypto_used_network:
          category: SHOULD
          future: true
          na_allowed: true
      - crypto_tls12:
          category: SHOULD
          future: true
          na_allowed: true
      - crypto_certificate_verification:
          category: MUST
          future: true
          na_allowed: true
      - crypto_verification_private:
          category: SHOULD
          future: true
          na_allowed: true
      - hardened_site: # After delivery_mitm?
          category: SUGGESTED
          future: true
          autofill: >
            Load the URLs and look for those HTTP headers. In the future, we
            may want to specify certain disallowed content security policies.
            See http://content-security-policy.com/.
      - hardening: # In 'Other security issues'
          category: SUGGESTED
          future: true
          autofill: >
            Look for gems like secure_headers, and
            relevant compiler flags in build files.
